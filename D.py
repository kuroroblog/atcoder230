################################
# <方針>
# なるべく1度のパンチで多くの壁を壊したい。 ⏩ どの列にパンチを加えるべきか考える。
# 以下の処理を繰り返す。
# 1. 左の列から見た場合に、壁の右端が最初に現れるものに注目する。
# 2. 上記の壁の右側へパンチを加える。 ⏩ 上記の壁の右端以外にパンチするよりも、右端でパンチした方が重複して壁を壊せる確率が上がるため。
# 3. パンチにより、壊れた壁を除いた、残りの壁に対して壁の右端が最初に現れるものに注目する。2と3を繰り返す。
#
# 壁の右端が最初に現れるものを容易に探索するために、どうすべきか? ⏩ 事前に壁の右側でソートしておく。
#
################################

# 標準入力を受け付ける。
N, D = map(int, input().split())

wallList = []

for _ in range(N):
    L, R = map(int, input().split())
    wallList.append((L, R))


wallList.sort(key=lambda x: x[1])

# パンチの数。
punch_cnt = 1
# パンチにより壁を壊すことのできる範囲。
punch_right = wallList[0][1] + D - 1
for i in range(1, N):
    # パンチにより続けて壁を壊せる場合、continueを行う。
    if wallList[i][0] <= punch_right:
        continue

    # パンチにより壁を壊すことのできる範囲。
    punch_right = wallList[i][1] + D - 1
    punch_cnt += 1

print(punch_cnt)
